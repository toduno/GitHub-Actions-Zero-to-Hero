# GitHub Actions - 
1. platform-oriented solutions and doesn't support many tools e.g. other vcs like gitlab, bitbucket, aws CodeCommit, azure devops, as this is scoped to one platform i.e. GitHub vcs
2. Don't need to install plugins, by default Github seamlessly integrates with the actions file, provides what's required and executes the job (same as pipeline in Jenkins) in the actions file/pipelines. The plugins are auto installed in Github by default. 
e.g. on: [push/pull] - irrespective of what push/pull/issue action, once defined Github will look into the action then watch for the CI files and understand what needs to be done and start executing the actions file
3. Pipelines or actions files can be created in a .github/workflows folder in the root folder of the repo
   and it follos the yaml standard
4. You can have multiple pipelines or actions files e.g. one to check pull reqs maybe a user has provided all details in the pull req or not, one to verify formatting/linking issues, one to check if CI is passing, one for CD, others (sample from argo-cd workflows: release.yml, ci-build.yml, codequality.yml, image.yaml, pr-title-check.yml, update-sync-for-vulnerabilities.yml) - all boils down to what you want to do, and whatever actions you configure e.g. on: [push,pull,issue] - Github doesn't mind executing your pipelines on the actions you provided. If you provide 3 actions it'll know that either of the action has to be matched before it starts executing the pipeline.
5. You can have multiple jobs in one file which is like executing multiple pipelines in one file.
6. You checkout the code from jobs: build to matrix, then next step which is steps: starts your steps where you write your actual code i.e. what the actions file will use to execute the file. All the steps e.g. checkout step are gotten from GitHub actions docs which is a standard to follow if you don't know how to figure out these things everytime, there you see everything about Github actions like plugins it provides etc.
7. With Github actions, you're advantaged to write very less code because the config is quite similar for different applications whether it's pythin app, node app, java app as you're only playing with the plugins which are already installed but this plugins are very limited in scope. To identify plugins or what plugins in the config, check jobs: build: steps: uses: e.g. actions/setup-python@v2 (for python plugin from which you can be able to configure a python env in the container to run/test the code)
8. Because Github actions is new in the market compared to Jenkins and other old CI/CD tools, it's still a budding tool compared to them.
9. You can configure custom runners in Github actions and execute on it. Similar to Jenkins either you use Docker containers or create your own host runners or create your own worker nodes and use on it if you're not happy with the default runners Gthub is providing (because they can be light in nature or not have enough compute resources and you might want to do some load testing which Github actions is not providing).
10. Github actions provides where to store secrets for CI/CD 